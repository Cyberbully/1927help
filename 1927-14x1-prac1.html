<h1>Linked List</h1>

<h2>Basics</h2>
<ul>
    <li>Complete this function: <code>int countNodes(link head)</code></li>
    <li>Complete this function: <code>link deleteAtPosition(link head, int k)</code> - you do not have to free the deleted node. Node index starts at zero.</li>
    <li>Complete this function: <code>link insertAtPosition(link head, int k, link insert)</code>. Node index starts at zero.</li>
    <li>Complete this function: <code>link insertInOrder(link head, link insert)</code>, which inserts a node in a linked list in order</li>
    <li>Complete this function: <code>link reverse(link head)</code>, which reverses a linked list.</li>
    <li>Complete this function: <code>link backToFront(link head)</code>, which puts the last element of a linked list at the front.</li>
    <li>Complete this function: <code>link frontToBack(link head)</code>, which puts the first element at the back</li>
</ul>

<h2>More Advanced</h2>
<ul>
    <li>Complete this function: <code>link maxToFront(link head)</code></li>
    <li>Complete this function: <code>link generateFibonacci(int k)</code>, which a linked list in the fibonacci sequence, e.g. <code>generateFibonacci(5)</code> gives 1, 1, 2, 3, 5 (Fibonacci Sequence starts at 1, 1, then adds the two previous numbers.</li>
    <li>Complete this function: <code>link unionList(link list1, link list2)</code>, which, given the two lists are in order, returns a new list (so copy the nodes) of the union of the two lists. For example, if list1 contains [1]-[2]-[4] and list2 contains [2]-[4], you would return [1]-[3]-[4]</li>
    <li>Complete this function: <code>link intersectionList(link list1, link list2)</code>, which, given the two lists are in order, returns a new list (so copy the nodes) of the intersection on of the two lists. For example, if list1 contains [1]-[2]-[4] and list2 contains [2]-[4], you would return [1]</li>
    
    
    <li>Complete this function: <code>link zipList(link list1, link list2)</code>, which zips two lists (with any number of nodes) together, e.g. [1]-[5]-[9] and [2]-[7]-[9]-[15] becomes [1]-[2]-[5]-[7]-[9]-[9]-[15]</li>
    
    <li>Complete this function: <code>link removeConsecutiveDuplicates(link head)</code>, which, given a linked list which has duplicates in a row, removes them - e.g. [1]-[1]-[2]-[3]-[3] becomes [1]-[2]-[3]</li>   
</ul>

<h2>Interview Type Questions</h2>
<ul>
    <li>Complete this function: <code>link findMiddle(link head)</code>, which finds the middle of the linked list. Note you only have to traverse the linked list once.</li>
    <li>Complete this function: <code>link nodeFromEnd(link head, int k)</code>, which finds the kth node from the end (k = 0 is the last element). Note: you can do this only traversing the linked list once!</li>    
    
    <li>Complete this function: <code>int isPalindrome(link head)</code>, which returns whether a linked list is a palindrome. You may need to create a new list..</li>
    
    
</ul>

<h1>Binary Search Tree</h1>

<h2>Basics</h2>
<ul>
    <li>Complete this function: <code>int countNodes(treelink tree)</code></li>
    <li>Complete this function: <code>int countLeaves(treelink tree)</code></li>
    <li>Complete this function: <code>treelink insert(treelink tree, treelink insert)</code></li>
    <li>Complete this function: <code>int height(treelink tree)</code>, which finds the height of the tree</li>
    <li>Complete this function: <code>treelink deleteLargest(treelink tree)</code></li>
    <li>Complete this function: <code>void printPrefix(treelink tree)</code>, which prints the integer data from a tree in prefix order. Do the same for infix and postfix.</li>
    <li>Complete this function: <code>int isDegenerate(treelink tree)</code>, which checks whether a tree is degenerate.</li>
</ul>

<h2>More Advanced</h2>
<ul>
    <li>Complete this function: <code>treelink copyTree(treelink tree)</code>, which duplicates the current tree.</li>
    <li>Complete this function: <code>link listFromTree(treelink tree, link list)</code>, which converts a tree to a tree in infix order. Can you do the same for prefix and postfix?</li>
    <li>Complete this function: <code>treelink isBST(treelink tree)</code>, which checks whether a tree is a binary search tree. Note that the solution left than is less than the current node, and greater than is greater than the current node, is not a solution.</li>
    <li>Complete this function: <code>treelink delete(treelink tree, int value)</code>, which deletes a node from a tree.</li>
</ul>
